Title:  Writeup for Project 2, Summer 2014
Date:  6/23/2014
Group Num 1 : Name            Email            Student ID
              Philip Lee      leephili@usc.edu 3759772007
              Byron Choy	  byroncho@usc.edu 7784820771

I. Requirements:
	Implement the system calls and exception handling of fork, exec, yield, and exit. 
	Also add in the syscalls for all the functions needed to use Locks and CVs.
	Add bullet-proofing to the syscalls.
	Implement multiprogramming by adding improving the page table. Also add in process table to keep track of threads and processes.
	Implement the hospital program from project 1 as a user program. 

II. Assumptions:
	Provided code works, except parts indicated to be changed.
	The physical memory size has been increased to match the needed number of pages. (Changed NumPhysPages to 1000)

III. Design:
	-addrspace.cc
	Addrspace has been changed to use a bitmap to determine which physical page to map to each virtual page when creating the address space.
	Loading of the executable has been moved into the loop that allocates pages, as the ReadAt function automatically will stop reading in pages when its done.
	A function has been added to easily allocate 8 pages for a new thread by the use of another bitmap to keep track of the pages created.
	Two functions have been created to clear up pages by going through the pageTable.
	One is in charge of releasing all pages in the address space for the physical page bitmap.
	The other releases only 8 pages of a process.

	-exception.cc
	Fork takes in the virtual address of the function to be run.
	It then validates the vaddr by checking if its within bounds and making sure it is not NULL.
	Then it creates a new thread, copies the address space from the current thread, and then allocates 8 pages from the address space's stack for this thread.
	The process table is then updated with the information.
	The function then finally calls nacho's Fork using fork_thread, while passing in the virtual address and the address of the first stack page allocated for it.
	The function fork_thread then sets the PCReg, NextPCReg, and StackReg to the values passed in through the forkInfo struct.

	Exec takes in the virtual address of a filename buffer.
	It then validates the virtual address.
	Then it checks to make sure you don't have too many processes at this point.
	The filename is then loaded from the buffer, and opened through the filesystem.
	A new addressspace and first thread for the new process is created.
	The process table is then updated with this information.
	Finally, exec forks with exec_thread, while passing in the 8 pages for the first thread.
	exec_thread loads the PCReg with address of main (0), and calls machine->Run() to start it.

	Exit has three main situations.
	1. Last thread in the last process
	Nachos checks to see if the thread is the last one in the last process.
	If so, nachos just calls Halt to end itself.
	2. Last thread in a process (not the last process)
	Nachos clears the memory pages, locks, and CVs allocated to the process.
	The page table is updated with this information.
	Then it calls Finish() on the current thread to end the process.
	3. Not last thread in a process
	The 8 pages allocated to the thread are freed up.
	The thread is ended with Finish();

	Yield just yields the currentThread as expected.

	Input validation was done on the included syscalls and fork/exec by checking to make sure virtual addresses provided were within bounds.
	Buffers were checked also by checking that the end point of the buffer is also within the bounds.

	-Locks'n'stuff


IV. Implementation:
	+ Files Modified
	userprog/exception.cc
	userprog/addrspace.cc
	userprog/progtest.cc
	userprog/addrspace.h
	userprog/syscall.h
	threads/system.cc
	threads/system.h
	test/start.s
	machine/machine.h (Only to increase the physical page limit)
	Any files changed in part 1 were also kept.

	+ Files added
	C Files with name format of test*.c in test directory for test suites.

	+ Data Structures added, and the file they were added to.
	-system.h
	struct ThreadEntry //Basic entry for thread
	struct ProcessEntry //Basic entry for a process

	-exception.cc
	struct forkInfo //Used to transfer information into fork_thread
	struct execInfo //Used to transfer information into exec_thread

	+ Data Structures modified, and the file they were added to.
	-addrspace.h
	class AddrSpace{
		Moved numPages to public.
		Added BitMap* pageBitMap for virtual page allocation.
		Added Lock* pageBitMapLock.
		Added executablePageCount to keep track of number of pages taken by executable.
		Added OpenFile* file for assignment 3 use.
	}

	+ Functions added and in which file.
	-addrspace.cc
	int AllocatePages(); //Allocates 8 pages from addrspace when called.
	void EmptyPages(); //Freed all physical pages allocated to addrspace.
	void Empty8Pages(); //Freed 8 physical pages allocated to a thread when called.

	-syscall.h
	Exec(); //Added size argument to function.

	-exceptions.cc
	void fork_thread() //Function passed to nachos fork to set registers for fork syscall
	void Fork_Syscall() //Fork syscall function
	void exec_thread() //Function passed to nachos fork to set registers for exec syscall
	void Exec_Syscall() //Exec syscall function
	void Yield_Syscall() //Yield syscall function
	int Exit_Syscall() //Exit syscall function
	bool validateAddress() //Function for validating vaddr
	bool validateBuffer() //Function for validating buffer address within vaddr bounds

	+ Functions modified and in which file.
	-addrspace.cc
	AddrSpace(); //Added mapping for physical to virtual page.

	-progtest.cc
	StartProcess(); //Added process table information for the first thread/process.

	-exception.cc
	Built in syscalls have input validation added at beginning.
	void ExceptionHandler() //Added syscalls to switch.

V. Testing:  (For each test case, you must show)

	+ How to test
	Call gmake in test and userprog directory. Run tests from userprog directory as indicated below.

	Fork Tests
	Call nachos -x ../test/testfork(1-3) individually to see the tests for fork.

	Exec Tests
	Call nachos -x ../test/testexec(1-3) individually to see the tests for exec.


	+ Test Output
	Fork Tests
	testfork1 - Should see two write messages saying "test1" and "test2". Nachos then ends.
	testfork2 - Should see various messages saying various error messages about fork input. Nachos should _not_ end. Will need to force quit.
	testfork3 - Should see 49 messages saying Creating test# to show the forks. The 50th should show "Unable to allocate pages for stack in Fork." Then 49 tests should be written out to show the other threads ending. Nachos then ends.

	Exec Tests
	exectest1 - Should show a single print of "test". Nachos then ends.
	exectest2 - Should see exec run 11 times. Error message "Too many processes for any more to be made!" should show up for last exec because too many processes. "test" is printed out 10 times. Nachos should end.
	exectest3 - The test prints out Unable to open file, Bad pointer to Open, and test.


VI. Discussion:
	+ Experiment expectation.  (What you hope will happen.)
	Fork Tests
	testfork1 - Should just end normally after printing out test1 and test2 into console.
	testfork2 - Should see error messages saying how fork failed. Nachos should not end because infinite loop in main to show that nachos didn't crash because of the failed forks.
	testfork3 - Should see messages showing forking threads. 50th thread should not fork, as that is the hard limit. Error message should indicate so. The other threads that forked should each print out test to indicate they ran.

	Exec Tests
	exectest1 - This should simply work by printing out "test" which is the user file called by exec. 
	exectest2 - There should be a short pause while the processes are created. Then a message saying too many processes should appear. Then the other 10 exec threads should print out "test" to show they ran successfully.
	exectest3 - The first exec checks a nonexisting file. This should return an open file error message. The second one tests invalid length for the filename. It should return an error regarding bad pointer. The last one uses an extra long filename. 


	+ Experiment result.  (What actually happens.)
	Fork Tests
	testfork1 - Nachos starts up and prints out "test1" and "test2".
	testfork2 - Nachos prints out "Bad vaddr passed to fork." 3 times for each bad fork attempt. Nachos then hangs on purpose because of the infinite yields.
	testfork3 - Nachos prints out test0 through test49. Then it prints out unable to allocate pages. Then it prints out test 50 times.

	ExecTests
	exectest1 - Nachos prints out "test".
	exectest2 - Nachos prints out "Too many processes for any more to be made!". THen it prints out "test" 10 times.
	exectest3 - Nachos prints out "Unable to open file ../test/testfile", "Bad pointer passed to Open", and "test".


	+ Explanation
	Fork Tests
	forktest1 - The two forked threads are created in main. After main ends, the two forked threads print out their respective test phrases to indicate they ran as well. Nachos then ends as expected.
	forktest2 - The bad values passed into fork are detected and kicked out. The infinite yields just shows that Nachos did not crash.
	forktest3 - The thread limit is hard coded at 50 per thread. The fork works for 50 times, but fails on the 51st cause the limit is reached. It then continues as normal to finish off the other 50 successfully forked threads.

	ExecTests
	exectest1 - The exec works because the file "testfile" is loaded and run. Testfile basically prints out test when run.
	exectest2 - The max process limit is reached on the 11th exec. The error message is printed. Then the other 10 execs should run as planned as shown by the 10 test print messages.
	exectest3 - The first two printouts are as expected. However, the third one worked, which was surprising. When the readin detected end of filename, it just fed in blanks for the buffer. This actually allowed the real file name to get fed in and run the testfiles correctly.


VII. Miscellaneous:
	The PhysNumPages has to be increased to a larger number (roughly 1000) for the 2 hospitals to work. 
	Current implementation uses 400 + code size / pages for each process.